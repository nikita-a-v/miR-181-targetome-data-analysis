---
title: "mir181 KO AGO binding sites definition"
author: "Mirko Br√ºggemann, Melina Klostermann"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  # pdf_document:
  #   fig_caption: true
  #   fig_crop: true
  #   toc: true
  #   toc_depth: 1
  #   number_sections: true
  BiocStyle::html_document:
    toc_float: TRUE
    code_folding: hide
    toc: TRUE
    number_sections: yes
    fig_caption: yes
params:
  config: "config"
---

```{r setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=F, cache.lazy = FALSE)
tidy.opts=list(width.cutoff=80,tidy=TRUE, echo=FALSE)
```


# Libraries and settings

```{r}
# ----------------------------------------
# libraries
# ----------------------------------------

library(rtracklayer)
library(GenomicRanges)
library(ggplot2)
library(AnnotationDbi)
library(dplyr)
library(reshape2)
library(UpSetR)
library(GenomicFeatures)
library(kableExtra)
library(knitr)
library(ggrepel)
library(gridExtra)
library(grid)
library(viridis)
library(BindingSiteFinder)
library(ComplexHeatmap)
library(forcats)
library(ggtext)
library(patchwork)
library(tibble)
library(tidyr)
library(dplyr)
library(ggpointdensity)
library(ggsci)
library(ggrepel)

here <- here::here()

source(paste0(here,"/Supporting_scripts/themes/theme_paper.R"))
source(paste0(here,"/Supporting_scripts/themes/CustomThemes.R"))


# ----------------------------------------
# settings
# ----------------------------------------

out <- paste0(here,"/Figure2/03_KOmir181_AGO_binding_site_definition/")


```


# What was done?

- Here we define AGO binding sites on basis of the non-chimeric non-enriched miR-eCLIP data with the mir181 knockout.
- Peaks are called with pureclip on the .bam merge of all three replicates.
- Then binding sites are defined with BindingSiteFinder. 
- Binding sites are filtered for their reproducibility in at least 2 of 3 samples.
- Then bindingsites are matched to the bound gene and the bound gene region.

*NOTE*: Large parts of code and text are from the BindingSiteFinder Vignette. For a detailed explanation see https://www.bioconductor.org/packages/release/bioc/vignettes/BindingSiteFinder/inst/doc/vignette.html

# Files

## Merge bam files run pureclip

We use the peakcaller pureclip to detect crosslink peaks. pureclip is run on the merge of the non-chimeric crosslinks of all three samples.

```{bash eval=FALSE, include=T}
# ------------------------------------
# Run pureclip
# ----------------------------------------

pureclip \
-i crosslinks_all_samples.sort.bam\
-bai crosslinks_all_samples.sort.bam.bai \
-g GRCm38.p6.genome.strict.IUPAC.fa \
-nt 10 \
-o IP_WT_pureclip_sites.bed \

```

```{r}
# ----------------------------------------
# ----------------------------------------
# Files
# ----------------------------------------
# ----------------------------------------

# ----------------------------------------
# annotation
# ----------------------------------------

annoDb <- readRDS(paste0(here, "/Supporting_scripts/annotation_preprocessing/annotation.rds"))
annoDb <- makeTxDbFromGRanges(annoDb) 
gns <- readRDS(paste0(here, "/Supporting_scripts/annotation_preprocessing/gene_annotation.rds"))

# ----------------------------------------
# pureclip sites (from peak calling)
# ----------------------------------------
pureclip_sites <- "/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/pureclip/IP_WT_pureclip_sites.bed"
pureclip_sites  = import(con = pureclip_sites , format = "BED", extraCols=c("additionalScores" = "character"))
pureclip_sites  = keepStandardChromosomes(pureclip_sites , pruning.mode = "coarse")
  
# ---------------------------------------- 
# Load clip data
# ----------------------------------------

clipFiles = "/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/pipe_output_22_02_14/non-chimeric/bw"
clipFiles = list.files(clipFiles, pattern = ".bw$", full.names = TRUE)
clipFiles = clipFiles[!grepl("Inp", clipFiles)]
clipFiles = clipFiles[!grepl("miR181_", clipFiles)]
clipFiles = clipFiles[grepl("KO", clipFiles)]
clipFilesP = clipFiles[grep(clipFiles, pattern = "plus")]
clipFilesM = clipFiles[grep(clipFiles, pattern = "minus")]

```


# Functions

```{r}
# ----------------------------------------
# utility functions
# ----------------------------------------

basicVectorToNiceDf <- function(x){
  # NOTE MK you could do all starting from the 3. line in one mutate command, might be faster and easier to read?
  df = data.frame(Type = names(table(x$olType)), Freq = as.vector(table(x$olType)))
  df = df[order(df$Freq, decreasing = F),]
  df$Type = factor(df$Type, levels = df$Type)
  df$Frac = df$Freq / sum(df$Freq)
  df$ymax = cumsum(df$Frac)
  df$ymin = c(0, head(df$ymax, n=-1))
  df$labPos = (df$ymax + df$ymin) / 2
  df$NFrac = round(df$Frac * 100)
  df$NFrac2 = round(df$Freq / sum(df$Freq), digits = 4)
  df$NFracNice = df$NFrac2 * 100
  df$labelNice = paste0(format(df$Freq, big.mark = ",", decimal.mark = "."), " (", df$NFracNice, "%)")
  df$labelNice2 = paste0(df$Type, ": ", format(df$Freq, big.mark = ",", decimal.mark = "."), " (", df$NFracNice, "%)")
  return(df)
}

```

# Preprocess pureCLIP output

Initial peak calling was performed with PureCLIP (see Melinas reports), which results in single nucleotide wide crosslink sites. These sites are pre-filtered before merging them into wider binding sites.

## Global filter

```{r}
# ----------------------------------------
# Filter peaks global by pureCLIP score
# ----------------------------------------

# Global 5% cutoff 

df = data.frame(score = pureclip_sites $score)
quantileCutoffpureClipScore = quantile(df$score, probs = seq(0,1, by = 0.05))
peaksFiltered = pureclip_sites [pureclip_sites $score >= quantileCutoffpureClipScore[2]]

```

PureCLIP score global filter. Distribution of the pureCLIP score. The red line indicates the 95% threshold used to keep only strong signal sites.


Here, PureCLIP called crosslink sites are filtered on a global level, removing sites with the lowest 5% PureCLIP score. This essentially removes crosslink sites that are only barely enriched above the local background. These sites rather contribute more noise to the data rather then enhancing the spectrum of detected sites to lowly abundant transcripts, since they are present uniformly across almost all transcripts. 

## Gene level filter
To enrich for the most prominent crosslink pattern one can restrict the binding site definition to the top 50% of PureCLIP sites per gene. This type of filter can be very restrictive, potentially removing a large proportion of the data. It is beneficial for detecting the strongest binding pattern presented in the data. It should be removed for the detection of finer more subtle binding pattern, or to allow for a high vs. low comparison scheme.


### Final gene level settings

Here we select for the top 50% highest PureCLIP site for each gene.

```{r}
# ----------------------------------------
# Filter peaks genewise by pureCLIP score
# ----------------------------------------

filterByRegion <- function(region, peaks, keepAbove) {
  # remove peaks not located on selected regions
  ols = findOverlaps(region, peaks)
  queries = unique(queryHits(ols))
  # apply selected cutoff to every region
  filteredPerRegion = sapply(queries, function(x){
    currentHits = subjectHits(ols)[queryHits(ols) == x]
    currentPeaks = peaks[currentHits]
    currentQuantiles = quantile(currentPeaks$score, probs = seq(0,1, by = 0.01))
    # NOTE MK actually you could use probs = keepAbove, and then score >= currentQuantile, you do not use the other quantiles here
    names(currentQuantiles) = seq(0,1, by = 0.01)
    filteredPeaks = currentPeaks[currentPeaks$score >= currentQuantiles[names(currentQuantiles) == keepAbove]]
    filteredPeaks
  })
  
  
  filteredPerRegion = unlist(GRangesList(filteredPerRegion))
  # Remove peaks on multiple regions
  filteredPerRegion = filteredPerRegion[countOverlaps(filteredPerRegion) == 1]
  # ----
  # Explanation: 
  # It can happen that a single peak overlaps multiple different genes. If that peaks
  # survives the filter for both genes the range of the peak would be duplicated in the output.
  # To prevent this from happening all duplicated peaks were removed to one unique representative
  # after the filtering.
  
  return(filteredPerRegion)
}

peaksFilteredPerGene = filterByRegion(gns, peaksFiltered, keepAbove = 0.5)

```

--> PureCLIP score gene level filter. Distribution of the pureCLIP score. Only the top 50% binding sites per gene are retained.


# Compute binding sites
## Merge and extend binding sites

```{r}
# -------------------------------
# set BS final options
# -------------------------------
bsSize_Final = 7
minWidth_Final = 2
minCrosslinks_Final = 2
minClSites_Final = 2
```

Next binding sites are merged into binding sites of a fixed width. Choosing this width parameter is explained in the following plots.

```{r }
# -------------------------------------------------------
# Organize clip data in dataframe for binding site finder
# -------------------------------------------------------

colData = data.frame(
  id = c(1:3),
  condition = factor(c("WT", "WT", "WT"),
                     levels = c("WT")),
                     clPlus = clipFilesP,
                     clMinus = clipFilesM)

# Make BindingSiteFinder object
bds = BSFDataSetFromBigWig(ranges = peaksFilteredPerGene, meta = colData)
bds

```
In total 3 samples from 1 condition(s) are used.




The final set of binding sites is computed with the same settings as the Ago2 binding sites (Figure1):

```{r}
    object = bds
    bsSize_Final = 7
    minWidth_Final = 2
    minCrosslinks_Final = 2
    minClSites_Final = 2
```

+ bsSize = `r bsSize_Final`
+ minWidth = `r minWidth_Final`
+ minCrosslinks = `r minCrosslinks_Final`
+ minClSites = `r minClSites_Final`

# Make binding sites

```{r}
# -------------------------------------------------------
# Make  binding sites
# -------------------------------------------------------
bds_sites <- makeBindingSites(object = bds, bsSize = bsSize_Final, minWidth = minWidth_Final,
                        minCrosslinks = minCrosslinks_Final, minClSites = minClSites_Final)

bds_sites_gr = getRanges(bds_sites)


df = getSummary(bds_sites) # NOTE MK nice function
kable(myNumberFormat(df), caption = "Merge and combine") 

```




# Reproducibility Filter

Since peak calling is based on the merge of all replicates, we filter processed binding site for their support by the individual replicates. First, crosslinks are summed up per replicate creating a crosslink distribution. Then, a threshold is set for each replicate to the 5% quantile of that distribution. To account for low crosslink replicates, a lower boundary of 1 crosslink events per binding site is enforced.


Finally, a binding sites is deemed reproducible if the thresholds are met for two out of three replicates. 

## Final binding sites

This leaves us with a final set of binding sites:

```{r}
# -------------------------------------------------------
# Get reproducible binding sites
# -------------------------------------------------------
bdsFinal = reproducibilityFilter(bds_sites, cutoff = 0.05, n.reps = 2)
bdsFinal = annotateWithScore(bdsFinal, getRanges(bds))
bdsFinal_gr = getRanges(bdsFinal)

kable(head(bdsFinal_gr))  %>%
  kable_material(c("striped", "hover"))
```
We get `r NROW(bdsFinal_gr)` reproducible binding sites.


# Downstream characterization

Next, we assign each binding site to the hosting gene and transcript part, using the initially loaded gene annotation from GENCODE.

## Assignment of binding sites to genes

Assigning each binding site to its hosting gene is done by computing the overlap of all binding sites with the gene annotation. This typically results in some binding sites overlapping multiple different genes.

```{r}
#-------------------------------------------------------------------------------
#   gene type priority rule
#-------------------------------------------------------------------------------
selectTerms = c("miRNA", "protein_coding", "tRNA", "lincRNA", "snRNA")
rule = unique(gns$gene_type)
rule = rule[!rule %in% selectTerms]
rule = c(selectTerms, rule)

# filter out pseudo genes
gns <- gns[!grepl(gns$gene_type, pattern = "pseudo")]

```
To resolve these overlaps genes are assigned based on the following hierarchical order:
"protein_coding" >"tRNA" > "lincRNA" > "miRNA" > "snRNA"

```{r}

#-------------------------------------------------------------------------------
#  Assign to genes
#-------------------------------------------------------------------------------

# get genes with binding signal
target_genes = subsetByOverlaps(gns, bdsFinal_gr)
df = findOverlaps(target_genes, bdsFinal_gr) %>% as.data.frame()

# split into easy and complex cases
idxDouble = df[duplicated(df$subjectHits),]
idxSingle = df[!duplicated(df$subjectHits),]

# handle single overlap cases
peaksRepoSingle = bdsFinal_gr[idxSingle$subjectHits]
mcols(peaksRepoSingle)$geneType = target_genes$gene_type[idxSingle$queryHits]
mcols(peaksRepoSingle)$geneName = target_genes$gene_name[idxSingle$queryHits]
mcols(peaksRepoSingle)$geneID = target_genes$gene_id[idxSingle$queryHits]%>% sub("\\..*", "", .)

# handle multi overlap cases
peaksRepoDouble = bdsFinal_gr[idxDouble$subjectHits]

peaksRepoDoubleCleaned = as(lapply(seq_along(peaksRepoDouble), function(x){
  currPeak = peaksRepoDouble[x]
  currtarget_genes = subsetByOverlaps(target_genes, currPeak)
  nOverlaps = length(currtarget_genes)
  
  # 1) take gene type as first criterion
  # -> prefer the type that is first in the `rule` list

  solution = unique(match(currtarget_genes$gene_type, rule))
  nSolutions = length(solution)
  
  if (nSolutions == nOverlaps) {
    # solution sucessfull
    mcols(currPeak)$geneType = currtarget_genes$gene_type[min(solution)]
    mcols(currPeak)$geneName = currtarget_genes$gene_name[min(solution)]
    mcols(currPeak)$geneID = currtarget_genes$gene_id[min(solution)]%>% sub("\\..*", "", .)
  }
  if (nSolutions < nOverlaps) {
    # no solution found 
    # -> Stop and return NA
    mcols(currPeak)$geneType = NA
    mcols(currPeak)$geneName = NA
    mcols(currPeak)$geneID = NA 
  }
  return(currPeak)
}),"GRangesList")
peaksRepoDoubleCleaned = unlist(peaksRepoDoubleCleaned)
peaksRepoDoubleCleaned = peaksRepoDoubleCleaned[!is.na(peaksRepoDoubleCleaned$geneID)]

# assign peaks

bsGene = c(peaksRepoSingle, peaksRepoDoubleCleaned)
bsGene = sortSeqlevels(bsGene)
bsGene = sort(bsGene)
bsGene = unique(bsGene) # why is the unique neccessary here?

# assign target_genes
target_genesGene = target_genes[target_genes$gene_id %in% bsGene$geneID]

```


## Assignment of binding sites to transcripts

```{r}
### setting the hierarchical rule for assignment
rule = c("utr3", "utr5", "cds", "intron")
```
The transcript parts bound by the RBP are identified by overlapping the binding sites of protein-coding genes with the transcripts of these genes. The respective transcript region, such as intron, CDS or UTR can be deduced from these overlaps. Similar to the gene assignment, some binding sites might also overlap with multiple different annotated transcript parts. These are resolved by application of the hierarchical rule: utr3, utr5, cds, intron. Note that the majority vote system is not used here!

```{r}
#-------------------------------------------------------------------------------
#  Assignment of binding sites to transcripts
#-------------------------------------------------------------------------------
# this is only done for protein coding genes
targetsProt = target_genes[target_genes$gene_type == "protein_coding"]
bsProt = bsGene[bsGene$geneType == "protein_coding"]
bsNonCodeing = bsGene[bsGene$geneType != "protein_coding"]
mcols(bsNonCodeing)$region = NA


### count the overlap of each binidng site within each part of the gene
# Count the overlaps of each binding site for each region of the transcript. 

cdseq = cds(annoDb) 
intrns = unlist(intronsByTranscript(annoDb)) 
utrs3 = unlist(threeUTRsByTranscript(annoDb)) 
utrs5 = unlist(fiveUTRsByTranscript(annoDb)) 
regions = list(CDS = cdseq, Intron = intrns, UTR3 = utrs3, UTR5 = utrs5)
# Count the overlaps of each binding site fore each region of the transcript. 
cdseq = regions$CDS %>% countOverlaps(bsProt,.)
intrns = regions$Intron %>% countOverlaps(bsProt,.)
utrs3 = regions$UTR3 %>% countOverlaps(bsProt,.)
utrs5 = regions$UTR5 %>% countOverlaps(bsProt,.)
countDf = data.frame(cds = cdseq, intron = intrns, utr3 = utrs3, utr5 = utrs5)


# sort by rule 
countDf = countDf[, rule] %>%
  as.matrix() %>% 
  cbind.data.frame(., outside = ifelse(rowSums(countDf) == 0, 1, 0) )
names = colnames(countDf)

# disable majority vote -> set all counts to 1
countDf = as.matrix(countDf) 
countDf[countDf > 0] = 1

region = apply(countDf, 1, function(x){ names[which.max(x)] })

# add region annotation to binding sites object
mcols(bsProt)$region = region

kable(table(region))  %>%
  kable_material(c("striped", "hover"))

```

# Save final binding sites

```{r}
bs_annotated <- c(bsProt, bsNonCodeing)

saveRDS(bs_annotated, paste0(out, "KOmir181_AGO_BS.rds"))

```



# Session Info

```{r}

sessionInfo()
```