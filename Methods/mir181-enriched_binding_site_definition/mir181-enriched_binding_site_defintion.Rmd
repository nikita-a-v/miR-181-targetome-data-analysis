---
title: "Enriched binding sites definition"
author: "Melina Klostermann"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  BiocStyle::html_document:
    toc_float: TRUE
    code_folding: hide
    toc: TRUE
    number_sections: yes
    fig_caption: yes
  # pdf_document:
  #   fig_caption: true
  #   fig_crop: true
  #   toc: true
  #   toc_depth: 1
  #   number_sections: true
---

```{r setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=F, cache.lazy = FALSE)
tidy.opts=list(width.cutoff=80,tidy=TRUE, echo=FALSE)
```

# Libraries and settings

```{r libraries}
# ----------------------------------------
# libraries
# ----------------------------------------

library(rtracklayer)
library(GenomicRanges)
library(ggplot2)
library(dplyr)
library(reshape2)
library(GenomicFeatures)
library(BindingSiteFinder)
library(ComplexHeatmap)
library(tibble)
library(tidyr)
library(dplyr)
library(ggrepel)
library(ggpointdensity)
library(purrr)
library(Biostrings)
library(BSgenome.Mmusculus.UCSC.mm10)
library(knitr)
library(kableExtra)



# ----------------------------------------
# settings
# ----------------------------------------

out <- "/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/R_github/miR181_paper/Methods/mir181-enriched_binding_site_definition/"
```

# Functions

```{r}
# ----------------------------------------
# utility functions
# ----------------------------------------

basicVectorToNiceDf <- function(x){
  # NOTE MK you could do all starting from the 3. line in one mutate command, might be faster and easier to read?
  df = data.frame(Type = names(table(x$olType)), Freq = as.vector(table(x$olType)))
  df = df[order(df$Freq, decreasing = F),]
  df$Type = factor(df$Type, levels = df$Type)
  df$Frac = df$Freq / sum(df$Freq)
  df$ymax = cumsum(df$Frac)
  df$ymin = c(0, head(df$ymax, n=-1))
  df$labPos = (df$ymax + df$ymin) / 2
  df$NFrac = round(df$Frac * 100)
  df$NFrac2 = round(df$Freq / sum(df$Freq), digits = 4)
  df$NFracNice = df$NFrac2 * 100
  df$labelNice = paste0(format(df$Freq, big.mark = ",", decimal.mark = "."), " (", df$NFracNice, "%)")
  df$labelNice2 = paste0(df$Type, ": ", format(df$Freq, big.mark = ",", decimal.mark = "."), " (", df$NFracNice, "%)")
  return(df)
}

```

# What was done?

- Here I define mir181 binding sites on basis of the enriched mir181 miR-eCLIP data.
- I merge the bam files and bw files from the non-chimeric and chimeric (after trimming off the mir part) read from the enriched mir181 data.
- Peaks are called with pureclip on the .bam merge of all three replicates.
- Then binding sites are defined with BindingSiteFinder. The used binding site size is 7nt to match with the AGO binding site definition. The bindingSiteCoverage plots show that 7nt fits the binding site patterns well.
- Binding sites are filtered for their reproducibility in at least 2 of 3 samples.
- Then bindingsites are matched to the bound gene and the bound gene region.

*NOTE*: Large parts of code and text are from the BindingSiteFinder Vignette. For a detailed explanaition see https://www.bioconductor.org/packages/release/bioc/vignettes/BindingSiteFinder/inst/doc/vignette.html

# Files

## Merge crosslinks of chimeric and non-chimeric reads

Here we use a merge of the chimeric and non-chimeric crosslinks from the enriched mir181 data. .bw files from chimeric and non-chimeric reads which are outputed from Raccon are merged in the commandline with uscs-bigWigMerge.

```{bash eval=FALSE, include=T}
# ----------------------------------------
# Merge bw non-chimeric and chimeric sample wise
# ----------------------------------------

bigWigMerge crosslinks_chimeric_sampleX.bw crosslinks_non-chimeric_sampleX.bw crosslinks_mixed_sampleX.bed

LC_COLLATE=C sort -k1,1 -k2,2n -k3,3n crosslinks_mixed_sampleX.bed -o crosslinks_mixed_sampleX.sort.bed

bedGraphToBigWig crosslinks_mixed_sampleX.sort.bed GRCm38.p6.genome.fa.fai  crosslinks_mixed_sampleX.sort.bw
```

## Merge bam files run pureclip

We use the peakcaller pureclip to detect crosslink peaks. pureclip is run on the merge of the three samples with both chimeirc and non-chimeric crosslinks.

```{bash eval=FALSE, include=T}
# ----------------------------------------
# Merge bam non-chimeric and chimeric (all samples together)
# ----------------------------------------

samtools merge -o crosslinks_mixed_all_samples.bam crosslinks_chimeric_all_samples.bamm crosslinks_non-chimeric_samples.bam
samtools sort crosslinks_mixed_all_samples.bam crosslinks_mixed_all_samples.sort.bam
samtools index crosslinks_mixed_all_samples.sort.bam

# ----------------------------------------
# Run pureclip
# ----------------------------------------

pureclip \
-i crosslinks_mixed_all_samples.sort.bam\
-bai crosslinks_mixed_all_samples.sort.bam.bai \
-g GRCm38.p6.genome.strict.IUPAC.fa \
-nt 10 \
-o mixed_IP_WT_miR181_pureclip_sites_230323.bed \

```

```{r}
# ----------------------------------------
# ----------------------------------------
# Files
# ----------------------------------------
# ----------------------------------------

# ----------------------------------------
# annotation
# ----------------------------------------

annoDb <- loadDb("/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/R_github/miR181_paper/Methods/01_Annotation_preprocessing/annotation.db")
gns <- readRDS("/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/R_github/miR181_paper/Methods/01_Annotation_preprocessing/gene_annotation.rds")

# ----------------------------------------
# pureclip sites (from peak calling)
# ----------------------------------------
pureclip_sites <- "/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/pureclip/mixed_IP_WT_miR181_pureclip_sites_230323.bed"

# ----------------------------------------
# crosslinks
# ----------------------------------------

# crosslinks mixed  chimeric, non-chimeric
clipFiles = "/Users/melinaklostermann/Documents/projects/AgoCLIP_miR181/pipe_output_22_02_14/chimeric/crosslinks_mixed"
clipFiles = list.files(clipFiles, pattern = ".bw$", full.names = TRUE)
clipFiles  = clipFiles[!grepl("Inp", clipFiles)]
clipFiles  = clipFiles[grepl("miR181_", clipFiles)]
clipFiles  = clipFiles[grepl("WT", clipFiles)]
clipFilesP  = clipFiles[grep(clipFiles, pattern = "plus")]
clipFilesM  = clipFiles[grep(clipFiles, pattern = "minus")]



```



# Obtained pureclip sites (from peak calling)

```{r}
# ----------------------------------------
# Get and clean pureclip sites
# ----------------------------------------

pureclip_sites <- import.bedGraph(pureclip_sites)
pureclip_sites = as.data.frame(pureclip_sites)
pureclip_sites$score =  pureclip_sites$NA.
pureclip_sites$strand = pureclip_sites$NA..1
pureclip_sites$NA. = NULL
pureclip_sites$NA..1 = NULL
pureclip_sites$NA..2 = NULL
pureclip_sites = makeGRangesFromDataFrame(pureclip_sites, keep.extra.columns = T)
pureclip_sites = keepStandardChromosomes(pureclip_sites, pruning.mode = "coarse")

kable(head(pureclip_sites)) %>%
  kable_material(c("striped", "hover"))

```

--> Number of pureclip sites: `r NROW(pureclip_sites)`

# Compute binding sites

## Settings for binding sites

```{r}
# -------------------------------
# set BS final options
# -------------------------------
bsSize_Final = 7
minWidth_Final = 2
minCrosslinks_Final = 2
minClSites_Final = 2
```

## Make BindingSiteFinder object

```{r}
# -------------------------------------------------------
# Organize clip data in dataframe for binding site finder
# -------------------------------------------------------

colData= data.frame(
  id = c(1:3),
  condition = factor(c("WT", "WT", "WT"),
                     levels = c("WT")),
                     clPlus = clipFilesP  ,
                     clMinus = clipFilesM)

# Make BindingSiteFinder object
bds = BSFDataSetFromBigWig(ranges = pureclip_sites, meta = colData)
bds

```

## Controls for binding site width setting

We use a binding site width of 7nt because this setting was chosen for the AGO binding sites. With the following plots we doublecheck that 7 is a suitable size for the enriched mir181 binding sites. \newline
\newline
The optimal binding site width is determined by the binding site signal to noise ratio. For each binding site, the ratio of crosslink events within the binding site and of crosslink events flanking the binding site to both sides is determined.

```{r}
# -------------------------------------------------------
# SupportRatio plot
# -------------------------------------------------------
supportRatioPlot(bds, bsWidths = seq(from = 3, to = 29, by = 2), minWidth = minWidth_Final, minClSites = minClSites_Final, minCrosslinks = minCrosslinks_Final)

```
This plot shows that the optimal resolution of signal in binding sites would be for 9nt or 11nt binding sites.

For further visual inspection selected binding site width are plotted as count profiles centered around the binding sites central position.
```{r}
# -------------------------------------------------------
# RangeCoverage plot
# -------------------------------------------------------

bds1 <- makeBindingSites(object = bds, bsSize = 3, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

bds2 <- makeBindingSites(object = bds, bsSize = 5, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

bds3 <- makeBindingSites(object = bds, bsSize = 7, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

bds4 <- makeBindingSites(object = bds, bsSize = 9, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

bds5 <- makeBindingSites(object = bds, bsSize = 15, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

bds6 <- makeBindingSites(object = bds, bsSize = 17, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

bds7 <- makeBindingSites(object = bds, bsSize = 11, minWidth = 2,
                              minCrosslinks = 2, minClSites = 2, sub.chr = "chr1")

l = list(`1. bsSize = 3` = bds1, `2. bsSize = 5` = bds2, `3. bsSize = 7` = bds3,
         `4. bsSize = 9` = bds4, `5. bsSize = 11` = bds7, `6. bsSize = 15` = bds5)

rangeCoveragePlot(l, width = 20) 


```

In generally, a binding site width of 9nt would be ideal for this data. However, for reasons of comparability we stay with a size of 7nt.

## Make binding sites

```{r}
# -------------------------------------------------------
# Make  binding sites
# -------------------------------------------------------
bds_sites <- makeBindingSites(object = bds, bsSize = bsSize_Final, minWidth = minWidth_Final,
                        minCrosslinks = minCrosslinks_Final, minClSites = minClSites_Final)

bds_sites

# make GrangesObject of binding sites
bds_sites_gr = getRanges(bds_sites)
bds_sites_gr

df = getSummary(bds_sites) # NOTE MK nice function
kable(df)  %>%
  kable_material(c("striped", "hover"))

```

## Binding site composition

Details about the binding site computation can be seen when counting the number of PureCLIP sites that make up a specific binding site.

```{r}
# -------------------------------------------------------
# Check pureclip sites per binding site
# -------------------------------------------------------

df = countOverlaps(bds_sites_gr, pureclip_sites) %>%
    table() %>%
    as.data.frame() 
colnames(df) <- c("n", "Freq")

ggplot(df, aes(x = n, y = Freq, fill = n)) +
    geom_col(color = "black") +
    scale_fill_grey() +
    theme_bw() +
    theme(legend.position = "none") +
    labs(
        title = "Number of PureCLIP sites per binding site",
        x = "PureCLIP sites",
        y = "#Count"
    )
```

## Reproducibility filter

Since peak calling is based on the merge of all replicates, we filter processed binding site for their support by the individual replicates. First, crosslinks are summed up per replicate creating a crosslink distribution. Then, a threshold is set for each replicate to the 5% quantile of that distribution. To account for low crosslink replicates, a lower boundary of 1 crosslink events per binding site is enforced.

```{r}
# -------------------------------------------------------
# Check reproducibility cutoff
# -------------------------------------------------------

p <- reproducibiliyCutoffPlot(bds_sites, max.range = 20, cutoff = 0.05)

p
```
Finally, a binding sites is deemed reproducible if the thresholds are met for all two of three replicates. The Upset plot below shows the support intersections of the three samples for the binding sites.

```{r}
# -------------------------------------------------------
# Check reproducibility of binding sites between the three non-chimeric and the three chimeric samples
# -------------------------------------------------------
s1 = reproducibilityFilter(bds_sites, cutoff = 0.05, n.reps = 2, returnType = "data.frame")
m = make_comb_mat(s1, mode = "distinct")

df = strsplit(names(comb_degree(m)), "")
df = do.call(rbind,df) 
df = as.matrix(df)
df = apply(df, 2, as.numeric)
df = as.data.frame(df)

df$support = rowSums(df)
rownames(df) = names(comb_degree(m))


df$status = ifelse(df$support == 3, "All", 
                                        ifelse(df$support == 2, "Two", 
                                               ifelse(df$support == 1, "One", "None")))


# plot Upset with Complex Heatmap package
ha = HeatmapAnnotation(
  col = list(select = c("All" = "#004d4d",  "Two" = "aquamarine4", "One" = "aquamarine2", "None" = "grey")),
  "Sample intersections" = anno_barplot(comb_size(m), border = FALSE, gp = gpar(fill = "#595959"), height = unit(6, "cm")),
    select = df$status
)

ht = UpSet(m,
           set_order = colnames(s1),
           comb_order = order(comb_size(m), decreasing = T),
           top_annotation = ha,
           comb_col = "cornflowerblue", bg_col = "white", pt_size = unit(.5, "cm") ,
           border = T, lwd = 2, bg_pt_col = "#333333"
)

ss = set_size(m)
cs = comb_size(m)
ht = draw(ht,  padding = unit(c(0, 0, 10, 0), "mm"))
od = column_order(ht)
decorate_annotation("Sample intersections", {
    grid.text(format(cs[od], big.mark = ",", decimal.mark = "."), x = seq_along(cs), y = unit(cs[od], "native") + unit(.1, "pt"), 
        default.units = "native", just = c("left", "bottom"), 
        gp = gpar(fontsize = 6, col = "black"), rot = 45)
})



```

## Final binding sites

This leaves us with a final set of binding sites:

```{r}
# -------------------------------------------------------
# Get reproducible binding sites
# -------------------------------------------------------
bdsFinal = reproducibilityFilter(bds_sites, cutoff = 0.05, n.reps = 2)
bdsFinal = annotateWithScore(bdsFinal, getRanges(bds))
bdsFinal_gr = getRanges(bdsFinal)

kable(head(bdsFinal_gr))  %>%
  kable_material(c("striped", "hover"))


```

We get `r NROW(bdsFinal_gr)` reproducible binding sites.

## Examples

```{r warnings =F }
set.seed(123)

s <- sample(1:NROW(bdsFinal_gr), 8) %>% as.list(.)

lapply(s, function(x) bindingSiteCoveragePlot(bdsFinal, 
                                              plotIdx = x, 
                                              flankPos = 20, 
                                              autoscale = TRUE, 
                                              customRange = pureclip_sites, 
                                              customRange.name = "pSites"))
```


# Downstream characterization

Next, we assign each binding site to the hosting gene and transcript part, using the initially loaded gene annotation from GENCODE.

## Assignment of binding sites to genes

Assigning each binding site to its hosting gene is done by computing the overlap of all binding sites with the gene annotation. This typically results in some binding sites overlapping multiple different genes.

```{r}
#-------------------------------------------------------------------------------
#   gene type priority rule
#-------------------------------------------------------------------------------
selectTerms = c("protein_coding", "tRNA", "lincRNA", "miRNA", "snRNA")
rule = unique(gns$gene_type)
rule = rule[!rule %in% selectTerms]
rule = c(selectTerms, rule)

# filter out pseudo genes
gns <- gns[!grepl(gns$gene_type, pattern = "pseudo")]

```

To resolve these overlaps genes are assigned based on the following hierarchical order:
"protein_coding" >"tRNA" > "lincRNA" > "miRNA" > "snRNA"

```{r}
#-------------------------------------------------------------------------------
#  Assign to genes
#-------------------------------------------------------------------------------

# get genes with binding signal
target_genes = subsetByOverlaps(gns, bdsFinal_gr)
df = findOverlaps(target_genes, bdsFinal_gr) %>% as.data.frame()

# split into easy and complex cases
idxDouble = df[duplicated(df$subjectHits),]
idxSingle = df[!duplicated(df$subjectHits),]

# handle single overlap cases
peaksRepoSingle = bdsFinal_gr[idxSingle$subjectHits]
mcols(peaksRepoSingle)$geneType = target_genes$gene_type[idxSingle$queryHits]
mcols(peaksRepoSingle)$geneName = target_genes$gene_name[idxSingle$queryHits]
mcols(peaksRepoSingle)$geneID = target_genes$gene_id[idxSingle$queryHits] %>% sub("\\..*", "", .)

# handle multi overlap cases
peaksRepoDouble =  bdsFinal_gr[idxDouble$subjectHits]

peaksRepoDoubleCleaned = as(lapply(seq_along(peaksRepoDouble), function(x){
  currPeak = peaksRepoDouble[x]
  currTargets = subsetByOverlaps(target_genes, currPeak)
  nOverlaps = length(currTargets)
  
# 1) take gene type as first criterion
# -> prefer the type that is first in the `rule` list

  solution = unique(match(currTargets$gene_type, rule))
  nSolutions = length(solution)
  
  if (nSolutions == nOverlaps) {
    # solution sucessfull
    mcols(currPeak)$geneType = currTargets$gene_type[min(solution)]
    mcols(currPeak)$geneName = currTargets$gene_name[min(solution)]
    mcols(currPeak)$geneID = currTargets$gene_id[min(solution)] %>% sub("\\..*", "", .)
  }
  if (nSolutions < nOverlaps) { 
    # no solution found 
    # -> Stop and return NA
    mcols(currPeak)$geneType = NA
    mcols(currPeak)$geneName = NA
    mcols(currPeak)$geneID = NA
  }
  return(currPeak)
}),"GRangesList")
peaksRepoDoubleCleaned = unlist(peaksRepoDoubleCleaned)
peaksRepoDoubleCleaned = peaksRepoDoubleCleaned[!is.na(peaksRepoDoubleCleaned$geneID)]

# assign peaks
bsGene = c(peaksRepoSingle, peaksRepoDoubleCleaned)
bsGene = sortSeqlevels(bsGene)
bsGene = sort(bsGene)
bsGene = unique(bsGene) # why is the unique neccessary here?

# assign targets
target_genes = target_genes[target_genes$gene_id %in% bsGene$geneID]

```

We get `NROW(bsGene)` binding sites, that can be assigned to a gene. (Note: These are some less then the number of binding sites we had before, because, some binding sites might be othside of annotated genes.) \newline
The binding sites are positioned on `NROW(target_genes)` genes.

## Assignment of binding sites to transcripts

```{r}
### setting the hierarchical rule for assignment
rule = c("utr3", "utr5", "cds", "intron")
```

The transcript parts bound by the RBP are identified by overlapping the binding sites of protein-coding genes with the transcripts of these genes. The respective transcript region, such as intron, CDS or UTR can be deduced from these overlaps. Similar to the gene assignment, some binding sites might also overlap with multiple different annotated transcript parts. These are resolved by application of the hierarchical rule: utr3, utr5, cds, intron. Note that the majority vote system is not used here!

```{r}
#-------------------------------------------------------------------------------
#  Assignment of binding sites to transcripts
#-------------------------------------------------------------------------------
# this is only done for protein coding genes
targetsProt = target_genes[target_genes$gene_type == "protein_coding"]
bsProt = bsGene[bsGene$geneType == "protein_coding"]
bsNonCodeing = bsGene[bsGene$geneType != "protein_coding"]
mcols(bsNonCodeing)$region = NA


### count the overlap of each binidng site within each part of the gene
# Count the overlaps of each binding site for each region of the transcript. 

cdseq = cds(annoDb) 
intrns = unlist(intronsByTranscript(annoDb)) 
utrs3 = unlist(threeUTRsByTranscript(annoDb)) 
utrs5 = unlist(fiveUTRsByTranscript(annoDb)) 
regions = list(CDS = cdseq, Intron = intrns, UTR3 = utrs3, UTR5 = utrs5)
# Count the overlaps of each binding site fore each region of the transcript. 
cdseq = regions$CDS %>% countOverlaps(bsProt,.)
intrns = regions$Intron %>% countOverlaps(bsProt,.)
utrs3 = regions$UTR3 %>% countOverlaps(bsProt,.)
utrs5 = regions$UTR5 %>% countOverlaps(bsProt,.)
countDf = data.frame(cds = cdseq, intron = intrns, utr3 = utrs3, utr5 = utrs5)


# sort by rule 
countDf = countDf[, rule] %>%
  as.matrix() %>% 
  cbind.data.frame(., outside = ifelse(rowSums(countDf) == 0, 1, 0) )
names = colnames(countDf)

# disable majority vote -> set all counts to 1
countDf = as.matrix(countDf) 
countDf[countDf > 0] = 1

region = apply(countDf, 1, function(x){ names[which.max(x)] })

# add region annotation to binding sites object
mcols(bsProt)$region = region

kable(table(region))  %>%
  kable_material(c("striped", "hover"))

```

# Save final binding sites

```{r}
bs_annotated <- c(bsProt, bsNonCodeing)

saveRDS(bs_annotated, paste0(out, Sys.Date(), "-BS_mir181_enriched.rds"))

```

# Session Info

```{r}

sessionInfo()
```
